---
lang: zh-CN    
title:  JAVA篇      
description: 页面的描述   
---

# JAVA篇

[[toc]]

## 面向对象(OOP)

面向对象是对面向过程的封装，封装了类的属性和方法。

## 对象创建的过程

对象创建之前，首先类被加载，先加载父类再加载子类，先构造父类再构造子类。

## 双亲委派机制

双亲委派机制是在classLoader里的loadClass方法里实现的，当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。

优点  
- 通过委派的方式，可以避免类的重复加载，当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。
- 通过双亲委派的方式，还保证了安全性。因为Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.Integer，那么这个类是不会被随意替换的，除非有人跑到你的机器上， 破坏你的JDK。那么，就可以避免有人自定义一个有破坏功能的java.lang.Integer被加载。这样可以有效的防止核心Java API被篡改。


## JAVA的反射机制

当类加载器将类加载进JVM之后，jvm会创建每一个类的元数据对象(Class)，JAVA语言允许通过元数据对象动态的创建对象实例，这种机制就称为JAVA的反射机制。
基本上所有框架的底层都用到了反射机制，Spring、Mybatis、Servlet都用到了。

## JAVA当中的多态是什么?

多态发生在父子类关系中，父类对象的引用指向子类的对象，方法的调用只能调用父类的方法。

## 数组和链表有什么区别?

- 数组会在内存当中开辟一块连续的存储空间，需要指定长度，数组当中的每一个元素都有索引，查询的话通过索引可以直接定位到某一个元素，效率很高，但是进行删除的话，数组会进行移动，所以效率很低。

- 链表不需要连续的存储单元，链表中的上一个元素通过指针指向下一个元素。链表结构进行查询的话，头部尾部比较快，中间元素查找速度比较慢，但是删除的话，只需要删除前后指针，重新建立指针就可以了，所以删除的性能很高。

## JAVA当中的集合类或集合框架（重点）

### Collection接口

Collection接口是集合类的顶层接口，Collection有两个子接口，一个List接口，一个是Set接口，List接口有序可重复，Set接口无序不可重复。  

- List接口常用的实现类有  

|Class|描述|
|--|--|  
|ArrayList|基于数组实现的|
|LinkedList|基于链表实现的，区别参考数组和链表区别|
|Vector|基于数组实现的，但是是线程安全的(synchronized)|
|CopyOnWriteArrayList|复制数组副本来实现的|

- Set接口常用实现类

|Class|描述|
|--|--|  
|HashSet|基于HashMap来实现的，实现不可重复是通过hashCode方法和equals方法进行两次比较，先比较hashCode，再通过equals比较，value可为空|
|TreeSet|基于二叉树来实现的，可以对元素进行排序(排序规则默认是自然顺序，可以自定义比较器，实现自定义排序)，value不可为空|

### Map接口

Map接口是和Collection同等级的根接口，它表示一个键值对（key-value）的映射，每一个key对应一个value，查找Map中的数据，总是根据key来获取，所以key是不可重复的。

- Map接口的常用的实现类有  

|Class|描述|
|--|--|  
|HashMap（重点）|基于数组和链表来实现的当存入一组键值对的时候，先对key进行hash，然后映射到一个初始化长度为16的数组上，当不同的key产生hash碰撞的时候，value会通过链表结构来进行存储，JDK1.8之后对HashMap进行了改进，当链表长度达到临界值8，会通过红黑树来存储value，HashMap有两个参数，一个是初始化数组长度16，负载因子0。75，当满足扩容阈值的时候(当数组的12个元素被存满，并且有hash碰撞了)，会动态扩容，以2倍的增长方式进行扩容。key不可重复，无序，可以为null |
|HashTable|HashTable是线程安全的hashMap（synchronized机制）。key不准许为null|
|TreeMap|TreeMap基于二叉树来实现的，可对key进行自然排序（自定义比较器，写比较规则）。key不准许为Null|
|ConcurrentHashMap（重点）|ConcurrentHashMap是线程安全的，对整个hash桶采用分段策略，拆分成若干个段segment，对每一个段上锁（synchronized），极大的提高了并发修改的效率。分段锁技术是在JAVA8以前使用的，在JAVA8已经弃用了，更新为synchronized+cas。key-value都不准许为null|

## Hash碰撞怎么解决

Hash碰撞的解决方式是开放寻址法和拉链法（链表）。

## 进程和线程有什么区别?

- 进程是指应用程序在运行时的状态，进程会占用系统的cpu以及内存资源
- 线程是指进程当中的执行流程，多个线程协同工作，会共同使用进程的资源，才确保进程的功能得以实现

## JAVA当中如何实现线程呢?

- 继承Thread类
- 实现runnable接口，只是任务类，还需手动创建线程对象
- 线程池机制来创建和管理线程(ThreadPool)

|线程池名称|描述|
|--|--|
|SingleThreadPool|创建一个线程的线程池|
|FixedThreadPool|创建固定数量的线程池|
|CachedThreadPool|数量可缓存的线程池|
|ScheduledThreadPool|有定时功能的线程池|

## 用线程池注意什么？

其实主要根据业务场景，来分配核心线程数量，最大线程数量

## 线程数过多哪个内存区域需要增加？

—每当有线程被创建的时候，JVM就需要为其在内存中分配虚拟机栈和本地方法栈来记录调用方法的内容，分配程序计数器记录指令执行的位置，这样的内存消耗就是创建线程的内存代价。

## 线程的生命周期

- 新建状态(new一个线程的时候)  
调用线程.start方法的时候，等待cpu分配时间片；
- 可运行状态  
当cpu分配到了时间片之后，线程开始运行，运行run方法当中的内容；
- 运行状态  
当线程遇到sleep、wait等方法的时候，线程会进入阻塞状态；
- 阻塞状态  
当休眠时间到期，或者被notify了，线程又回到了可运行状态；
- 死亡状态  
线程运行结束之后，就会销毁，被jvm的gc回收；

## 多线程并发或线程安全问题如何解决?

- 通过volatile关键字修饰变量，可以实现线程之间的可见性，避免变量脏读的出现，底层是通过限制jvm指令的重排序来实现的适用于一个线程写，多个线程读的场景； 
- 通过synchronized锁(任意对象)来实现线程同步，自动锁的思想，底层实现原理:当有线程进入同步代码块之后，利用jvm的计数器将锁的标记置为1，当别的线程再想进入的时候，发现锁的标记为1，该线程就去锁池等待，当第一个线程出来之后，锁的标记会置为0，
之后cpu会随机分配一个线程再次进入同步代码块；
- 通过使用Lock接口，进行手动Lock，和Unlock，但是这种很容易出现死锁。注意加锁以及解锁的顺序，就可以避免死锁；  
- 通过线程安全的集合类，可以解决并发问题，例如ConcurrentHashMap、CopyOnWriteArrayList；
- 使用并发包下面的原子类，底层使用的是cas机制（乐观锁）；  
- 使用ThreadLocal也可以解决并发问题；  

## ThreadLocal底层是怎么实现的

多个线程会复制一份ThreadLocal变量的副本进行操作，互不影响，来保证线程安全的。因为线程ID是唯一的，数据通过当前线程ID获取。  
- 注意事项：如果使用线程池，线程调度完后需要及时清除存在ThreadLocal的数据

## CountDownLatch和CyclicBarrier区别

- CountDownLatch和CyclicBarrier都是用作多线程同步，CountDownLatch基于AQS，CyclicBarrier基于ReentrantLock    
- CyclicBarrier支持复用和barrierCommand，但是CountDownLatch不支持。

## 线程之间如何进行通信?

- 使用synchronized锁的wait和notify进行等待和唤醒
- 使用lock锁的condition的await和signal进行等待唤醒

## 多线程并发原子性，可见性，有序性分析

- **原子性**：是指一个操作是不可中断，即使多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰；
- **可见性**：是指当线程1修改某一个共享变量的值，线程1修改完成以后，线程2能够立即知道修改完成后共享变量的值，那么说明是可见的；可见性就是说线程之间操作共享变量时，彼此之间都知道；
- **有序性**：有序性就是指执行代码是有序去执行，线程1先执行，完了之后线程2再去执行；

## 你知道哪些锁？

悲观锁、乐观锁、独占锁、共享锁、公平锁、非公平锁、分布式锁、自旋锁

## 请问公平锁与非公平锁的区别？

- 公平锁在获取锁资源时会先判断sync队列中是否存在正在获取锁资源的线程， 若没有， 则尝试获取锁，若有则等待
- 非公平锁，当线程争夺锁的过程中，会先进行一次CAS尝试获取锁

## 悲观锁和乐观锁

- 悲观锁的思想对线程并发持悲观态度，使用互斥锁的机制来解决并发问题  
- 乐观锁的思想是使用cas(compareAndSwapper)机制，不上锁，但也能解决并发问题  

## tcp和udp有什么区别?

- tcp是面向连接的，建立连接前需要进行三次握手，断开连接前需要进行四次挥手，可靠的不会造成数据丢失的，可以简单理解成打电话，效率低。
- udp协议是面向无连接，不可靠有可能造成数据丢失，可以理解成发电报，效率高。

## http协议和https协议区别

- http协议属于应用层的协议(封装的tcp)，现在大多的互联网都是通过Http协议进行连接，是免费协议
- https协议是安全的http协议，此协议是采用对称加密算法来保证数据传送的安全性，是收费协议

## 简述一下tcp协议三次握手或四次挥手的过程?

1：客户端发送syn包  
2：服务端接收到syn包之后，回复syn+ack  
3：客户端接收到服务端的syn+ack之后，会回复一个ack  

## get和post请求有什么区别?

- get请求是通过请求行url来传输参数的，安全性比较低，传输参数的大小不超过2KB效率快
- post请求是通过请求正文来提交数据的，安全性比较高，传输数据的大小不受限制，效率低

## 请求的转发和重定向有什么区别?

- 请求的转发使用的是同一个request对象，地址栏不发生改变
- 请求的重定向本质是两次请求，地址栏发生改变


## JVM的五大分区

|名称|说明|
|--|--|
|方法区|是所有线程共享的内存区域，可以动态扩展。用来存储类的信息，如：方法、方法名、返回值、常量等。当方法区无法满足内存分配需求时，会抛OutOfMemoryError。|
|堆|是所有线程共享的一块内存，用来存放new出来的对象信息、全局变量。|
|程序计数器|指向当前线程正在执行的行号，保证线程切换时能回到程序调用的位置。|
|虚拟机栈|也就是通常的栈内存，是Java方法执行的内存模型。描述的是线程进栈出栈的过程，线程结束时内存自动释放。主要用来存储当前线程运行方法所需的数据、指令、返回地址（即局部变量和正在调用的方法），方法在调用时会在栈中开辟一块空间栈帧，方法就在栈帧中运行。另：如果线程的请求的栈深度大于虚拟机的深度，就会抛出StackOverflowError异常，例如：死循环|
|本地方法栈|和虚拟机栈类似，只是描述的是虚拟机用到的native方法出栈和入栈的过程，其底层是C语言。|

## 什么时候对象可以进行垃圾收集？

- 引用计数算法（reference-counting） ：每个对象有一个引用计数器，当对象被引用一次则计数器加1，当对象引用失效一次则计数器减1，对于计数器为0的对象意味着是垃圾对象，可以被GC回收。
- 可达性算法(GC Roots Tracing)：从GC Roots作为起点开始搜索，那么整个连通图中的对象便都是活对象，对于GC Roots无法到达的对象便成了垃圾回收的对象，随时可被GC回收。

## 垃圾收集算法?

- 标记清除算法  
算法分为标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象
缺点：垃圾被回收以后造成了大量不连续的内存碎片

- 复制算法  
为了解决“标记，清除”算法的问题，它将内存平均分为两块，每次只使用其中一块，当这一块存满时触发垃圾收集，将还存活的对象复制到另一块内存，然后将这块内存清掉，这样就不会存在内存碎片的问题。

- 标记整理算法  
先把要回收的对象找出来以后让所有存活的对象向一端移动，然后将内存的剩余部分直接清理掉。

- 分代管理算法(新生代使用复制算法，年老代使用标记整理算法)  
因为老年代中对象的生命力比较顽强，如果采用复制算法那些存活的对象需要被复制很多次，所以老年代采用的是标记整理算法。

## JVM的调优机制

通常我们在项目当中，需要对jvm进行调优，以防止内存溢出的现象。主要通过调整jvm的启动参数，包括最小堆内存xms、最大堆内存xmx 栈内存xss，
由于jdk1.8永久代被弃用了，使用操作系统本地内存，所以不需要调节永久代大小了。
还包括使用并行的垃圾收集器，比如商用的CMS、G1垃圾收集器。
通常情况下，我们将最小堆内存和最大堆内存设置的一样，防止内存回落造成GC。在生产环境，我们通过使用Jconsole JvisualVm 对jvm可以进行监控。

## CMS和G1主要区别

- CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用，G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用
- G1比CMS会使用更多的内存和cpu负载，所以更适合用于大堆的应用  
- CMS收集器以最小的停顿时间为目标的收集器。G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型） 
- CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片，产生fullgc，G1收集器使用的是“标记-整理”算法，进行了空间整合，没有内存空间碎片。 
- CMS优点并发收集，低停顿，无法处理浮动垃圾，并发收集会造成内存碎片过多，G1回收器的特点，控制回收垃圾的时间，空间整理

## 什么情况下应该考虑使用G1

- 实时数据占用超过一半的堆空间
- 对象分配或者晋升的速度变化大
- 希望消除长时间的GC停顿（超过0.5-1秒）

## G1设置参数

控制G1回收垃圾的时间`-XX:MaxGCPauseMillis=200` （默认200ms）

## 内存为什么会出现溢出？

1、代码中存在死循环或循环产生过多重复的对象实体
2、使用的第三方软件中的BUG
3、我在项目中处理Excel文件时，由于文件很大，遇到过这个问题

## 内存溢出如何解决？

1、如果是因为jvm启动内存参数过小，则修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)
2、检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。
3、对代码进行走查和分析，找出可能发生内存溢出的位置。
4、对大数据量的处理采用分批策略




