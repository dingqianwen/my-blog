---
lang: zh-CN    
title:  数据库篇        
description: 页面的描述   
---

# 数据库篇

## 你是怎么设计数据库的？

设计数据库首先要遵循三大范式要求：原子性、依赖性、关联性  

1、原子性是指数据库表的每一列都是不可分割的原子数据项  
2、依赖性是指实体的属性完全依赖于主关键字。   
3、关联性是指任何非主属性不依赖于其它非主属性  

对于数据库设计来说，不仅仅要考虑范式要求，为了节省查询效率，允许适当的有一些冗余字段。

## 数据库调优（重点）

1、为了提高查询和写入性能,MySQL可以采取主从结构。
主数据库采用innodb引擎,从数据库采用mysam引擎,主从之间通过
同步binlog日志实现数据一致，数据库有两个线程，一个是IO线程，一个是SQL线程，从数据库通过IO线程监听主数据库的binlog日志然后写入中继日志中，SQL线程读取中继日志文件并对自身执行SQL命令从而保证数据的一致性。  
2、SQL优化,本质是通过创建索引,使用explain关键字,查询索引命中情况, 对SQL进行调优。  
3、使用cache层,预先对经常常用的数据库数据进行缓存,以减少数据库的压力提高数据库性能。  

## MySQL如何实现悲观锁和乐观锁

- mysql提供了表锁和行锁的机制(for update)，这就是悲观锁的体现  
select * from user where id=1 for update
- mysql没有提供乐观锁的机制,需要自己手动实现，用时间戳或者版本号

## 数据库索引是什么?

索引是数据库提供的利于快速查询的机制，索引类似于书签目录，
当查询条件那一列做了索引之后，那么数据库会去硬盘索引文件当中找到满足条件记录的物理位置，直接就可以定位以及获取记录。

## 索引的种类有哪些?

1、主键索引  
2、唯一索引  
3、单列索引  
4、外键索引  
5、组合索引（命中规则是最左原则）  

## SQL怎么调优，索引命中怎么知晓？（重点）

使用explain关键字查看SQL的执行计划,可以看到该SQL的索引命中情况、索引命中类型、命中率等相关的信息,通过这种方式
可以对SQL语句进行调优,对关键查询的条件创建索引以及注意一下sql语句的用法，尽量不使用like，尽量避免在某一列上进行运算，尽量不使用or


## explain执行计划包含的主要信息

|名称|说明|
|--|--|
|table|哪个表|
|select_type|查询的类型，主要是用于区分普通查询、联合查询、子查询等复杂的查询|
|type|访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL|
|key|实际使用的索引，如果为NULL，则没有使用索引。 |
|key_len|表示索引中使用的字节数，查询中使用的索引的长度（最大可能长度），并非实际使用长度，理论上长度越短越好。key_len是根据表定义计算而得的，不是通过表内检索出的|
|ref|显示索引的那一列被使用了，如果可能，是一个常量const。|
|rows|找到所需的记录所需要读取的行数|

## MySQL in 会触发索引吗

1、当in的取值范围较小时，in会走索引；  
2、当in的取值范围较大时，in不走索引，而是会用全表扫描。  

## 索引的常用数据结构?

- hash索引，均匀分布
- B树索引，分布有序

比如我对A列建立Hash索引，当我频繁对A列的数据进行修改的时候性能高，但是如果按照范围进行查找的话，B树索引的性能高

## 索引为什么使用B+树而不是B树

B+树是在B树的基础上又一次的改进，其主要对两个方面进行了提升，一方面是查询的稳定性，另外一方面是在数据排序方面更友好。  

1、B树只适合随机检索，而B+树同时支持随机检索和顺序检索;   
2、B+树空间利用率更高  
3、B+树的非叶子节点不保存具体的数据，而只保存关键字的索引，而所有的数据最终都会保存到叶子节点。因为所有数据必须要到叶子节点才能获取到，所以每次数据查询的次数都一样，这样一来B+树的查询速度也就会比较稳定

## 索引有什么优缺点?

索引可以提高查询的效率,但是对记录进行增删改的时候,由于数据库需要去维护索引文件,所以说如果频繁修改记录的话,影响数据库性能。我们在项目当中创建索引的时候,只是针对于那些频繁查询的字段创建索引,通常情况下创建索引的列不会超过6个

## 聚簇索引和非聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。非聚簇索引（辅助索引）在聚簇索引之上创建的索引称之为辅助索引。

- 优点  
1、数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快  
2、聚簇索引对于主键的排序查找和范围查找速度非常快  

- 缺点  
1、插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键  
2、更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。  
3、二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。  

## 组合索引(联合索引)与单列索引的区别？
多个单列索引在多条件查询时只会生效第一个索引！所以多条件联合查询时最好建组合索引,组合索引最左前缀原则,如果where条件中是OR关系，组合索引不起作用 


## 你用过存储过程么?

存储过程是预编译的,类似于函数,存储过程可以写SQL语句加流程语句

```sql
create Producer A(输入参数,输出参数)
begin
      //可以写sql  while if语句  
end
call A();
```

存储过程的优点，一次编写，多次调用；
缺点在分布式环境下，移植性有问题，单库使用存储过程比较多.

## MySQL的存储引擎有哪些,有什么区别（重点）

- 常用的就是InnoDB，数据库默认引擎是InnoDB，它对大规模写入的支持较好，支持数据库事务，支持外键，主要用于主从机构当中的主服务器  
- MYISAM它对大规模读的支持比较好,没有事务，主要用于从服务器

## 数据库的事务隔离级别

- 有4种:  
1、读 未提交  
2、读 已提交  
3、可重复性读  
4、串行化  

MySQL默认隔离级别为可重复性读，在一个事务内，多次读同一个数据。数据是不会变的。


## 事务的基本要素（ACID）

- **原子性（Atomicity）**：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。
- **一致性（Consistency）**：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
- **隔离性（Isolation）**：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。
- **持久性（Durability）**：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

## 事务的并发问题

- **脏读**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
- **不可重复读**：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
- **幻读**：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

## 那么MySQL可重复读是如何实现的呢？

使用的的一种叫MVCC的控制方式 ，即Mutil-Version Concurrency Control,多版本并发控制，类似于乐观锁的一种实现方式

实现方式：  
InnoDB在每行记录后面保存两个隐藏的列来，分别保存了这个行的创建时间和行的删除时间。这里存储的并不是实际的时间值,而是系统版本号，当数据被修改时，版本号加1
在读取事务开始时，系统会给当前读事务一个版本号，事务会读取版本号<=当前版本号的数据
此时如果其他写事务修改了这条数据，那么这条数据的版本号就会加1，从而比当前读事务的版本号高，读事务自然而然的就读不到更新后的数据了。

## 当前读和快照读？

- 当前读即读取最新提交的数据，当前读本质上是基于锁的并发读操作
- 快照读读取某一个快照建立时（可以理解为某一时间点）的数据，也称为一致性读。快照读本质上读取的是历史数据（原理是回滚段），属于无锁查询

