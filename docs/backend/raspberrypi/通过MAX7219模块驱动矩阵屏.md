---
lang: zh-CN  
title: 通过MAX7219模块驱动矩阵屏             
description: 页面的描述
---

# 通过MAX7219模块驱动矩阵屏

[[toc]]

### 所需材料

- 树莓派
- MAX7219模块
- 8 * 8 Led矩阵

### 模块以及针脚介绍

#### MAX7219

MAX7219是MAXIM公司生产的串行输入/输出共阴极数码管显示驱动芯片，一片MAX7219可驱动8个7段（包括小数点共8段）数字LED、LED条线图形显示器、或64个分立的LED发光二级管。该芯片具有10MHz传输率的三线串行接口可与任何微处理器相连，只需一个外接电阻即可设置所有LED的段电流。

<img src="https://oss-xuxin.oss-cn-beijing.aliyuncs.com/blog/img/lOqudg.png" alt="none" style="width: 35%;height: 35%;border-radius: 6px;">

各引脚的功能为：

> DIN：串行数据输入端  
> DOUT：串行数据输出端，用于级连扩展  
> LOAD：装载数据输入  
> CLK：串行时钟输入  
> DIG0~DIG7：8位LED位选线，从共阴极LED中吸入电流  
> SEG A~SEG G DP：7段驱动和小数点驱动  
> ISET： 通过一个10k电阻和Vcc相连，设置段电流

### 连接图

<img src="https://oss-xuxin.oss-cn-beijing.aliyuncs.com/blog/img/MAX7219.drawio.png" alt="none" style="width: 60%;height: 50%;border-radius: 6px;">

### 启用SPI

[如何开启SPI？](启用树莓派的SPI接口.md)

### 测试程序

例如我们通过程序输出一个笑脸，通过二维数组排列图形，坐标为0的点亮，为1的熄灭。

```text
{1, 1, 0, 0, 0, 0, 1, 1},
{1, 0, 1, 1, 1, 1, 0, 1},
{0, 1, 0, 1, 1, 0, 1, 0},
{0, 1, 1, 1, 1, 1, 1, 0},
{0, 1, 0, 1, 1, 0, 1, 0},
{0, 1, 1, 0, 0, 1, 1, 0},
{1, 0, 1, 1, 1, 1, 0, 1},
{1, 1, 0, 0, 0, 0, 1, 1}
```

那我们程序只要知道对应的矩阵屏坐标，即可轻而易举实现，其核心代码如下：

```java
public void setPixel(int x, int y, boolean enabled) {
    final byte mask = (byte) (1 << (WIDTH - 1 - x));
    if (enabled) {
        buffer[y] |= mask;
    } else {
        buffer[y] &= ~mask;
    }
}
```

#### 完整实现代码如下：

首先导入所需依赖

```xml

<dependencys>
    <dependency>
        <groupId>com.pi4j</groupId>
        <artifactId>pi4j-core</artifactId>
        <version>1.3</version>
    </dependency>
    <dependency>
        <groupId>com.pi4j</groupId>
        <artifactId>pi4j-gpio-extension</artifactId>
        <version>1.3</version>
    </dependency>
    
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-simple</artifactId>
        <version>1.7.32</version>
    </dependency>
</dependencys>
```

MAX7219工具类

```java
import com.pi4j.io.spi.SpiDevice;

import java.io.IOException;
import java.util.Arrays;

/**
 * 〈MAX7219〉
 *
 * @author 丁乾文
 * @date 2022/5/26 19:09
 * @since 1.0.0
 */
public class MAX7219 {

    /**
     * MAX7219: Internal Commands
     */
    private static final byte CMD_SET_FIRST_ROW = 0x01;
    private static final byte CMD_DECODE_MODE = 0x09;
    private static final byte CMD_INTENSITY = 0x0A;
    private static final byte CMD_SCAN_LIMIT = 0x0B;
    private static final byte CMD_SHUTDOWN = 0x0C;
    private static final byte CMD_DISPLAY_TEST = 0x0F;

    /**
     * Width of MAX7219 LED matrix
     */
    public static final int WIDTH = 8;

    /**
     * Height of MAX7219 LED matrix
     */
    public static final int HEIGHT = 8;

    /**
     * Internal buffer to store the 8x8 matrix
     * A byte[] array is used as each of the 8 bits is used to represent a column
     */
    protected final byte[] buffer = new byte[HEIGHT];

    /**
     * Pi4J SPI instance
     */
    protected final SpiDevice spi;

    /**
     * Creates a new MAX7219 instance using the given SPI instance from Pi4J.
     *
     * @param spi SPI instance
     */
    public MAX7219(SpiDevice spi) {
        this.spi = spi;
    }

    /**
     * Clears the internal buffer without refreshing the display.
     * This means that the current contents of the displays are still being shown until {@link #refresh()} is called.
     */
    public MAX7219 clear() {
        Arrays.fill(buffer, (byte) 0);
        return this;
    }

    /**
     * Flushes the internal buffer for all rows to the chip, causing it to be displayed.
     * The contents of the buffer will be preserved by this command.
     */
    public MAX7219 refresh() {
        for (int row = 0; row < HEIGHT; row++) {
            refreshRow(row);
        }
        return this;
    }

    /**
     * Flushes the internal buffer for a single row to the chip, causing it to be displayed.
     * The contents of the buffer will be preserved by this command.
     *
     * @param row Row to be flushed
     */
    protected void refreshRow(int row) {
        if (row < 0 || row >= HEIGHT) {
            throw new IllegalArgumentException("Row must be an integer in the range 0-" + HEIGHT);
        }

        execute((byte) (CMD_SET_FIRST_ROW + row), buffer[row]);
    }

    /**
     * Specifies if the LED matrix should be enabled or disabled.
     * This will also setup the proper decoding mode and scan limit when enabling the chip.
     *
     * @param enabled LED matrix state (true = ON, false = OFF)
     */
    public void setEnabled(boolean enabled) {
        if (enabled) {
            execute(CMD_SHUTDOWN, (byte) 0x01);
            execute(CMD_DECODE_MODE, (byte) 0x00);
            execute(CMD_SCAN_LIMIT, (byte) 0x07);
        } else {
            execute(CMD_SHUTDOWN, (byte) 0x00);
        }
    }

    /**
     * Enables or disables the testing mode of the LED matrix.
     * When enabled, all other options (including {@link #setEnabled(boolean)} are ignored and all LEDs are turned on.
     * To actually control the chip, the test mode MUST be disabled.
     *
     * @param enabled Test mode state (true = ON, false = OFF)
     */
    public void setTestMode(boolean enabled) {
        execute(CMD_DISPLAY_TEST, (byte) (enabled ? 0x01 : 0x00));
    }

    /**
     * Changes the desired brightness for the LED matrix.
     * This method expects an integer value within the range 0-15, with 0 being the dimmest and 15 the brightest possible value.
     * The whole display is affected by this command which gets immediately applied.
     *
     * @param brightness Desired brightness from 0-15
     */
    public void setBrightness(int brightness) {
        if (brightness < 0 || brightness > 15) {
            throw new IllegalArgumentException("Brightness must be an integer in the range 0-15");
        }
        execute(CMD_INTENSITY, (byte) brightness);
    }

    /**
     * Enables or disables the pixel at the given X/Y position within the internal buffer.
     * This change will not be visible until {@link #refresh()} or {@link #refreshRow(int)} gets called.
     *
     * @param x       X position to change
     * @param y       Y position to change
     * @param enabled Desired pixel state (true = ON, false = OFF)
     */
    public void setPixel(int x, int y, boolean enabled) {
        // Ensure coordinates are within boundaries
        checkPixelBounds(x, y);

        // Generate bitmask and set/unset specific bit
        final byte mask = (byte) (1 << (WIDTH - 1 - x));
        if (enabled) {
            buffer[y] |= mask;
        } else {
            buffer[y] &= ~mask;
        }
    }

    /**
     * 例如笑脸图案：
     * <pre>
     *     public static int[][] xl = {
     *             {1, 1, 0, 0, 0, 0, 1, 1},
     *             {1, 0, 1, 1, 1, 1, 0, 1},
     *             {0, 1, 0, 1, 1, 0, 1, 0},
     *             {0, 1, 1, 1, 1, 1, 1, 0},
     *             {0, 1, 0, 1, 1, 0, 1, 0},
     *             {0, 1, 1, 0, 0, 1, 1, 0},
     *             {1, 0, 1, 1, 1, 1, 0, 1},
     *             {1, 1, 0, 0, 0, 0, 1, 1}
     *     };
     * </pre>
     *
     * @param ints xy
     */
    public void push(int[][] ints) {
        for (int x = 0; x < ints.length; x++) {
            for (int y = 0; y < ints[x].length; y++) {
                checkPixelBounds(x, y);
                this.setPixel(x, y, ints[x][y] == 0);
            }
        }
        this.refresh();
    }

    /**
     * Retrieves the pixel at the given X/Y position within the internal buffer.
     *
     * @param x X position to change
     * @param y Y position to change
     * @return Current state of specified pixel (true = ON, false = OFF)
     */
    public boolean getPixel(int x, int y) {
        // Ensure coordinates are within boundaries
        checkPixelBounds(x, y);

        // Generate bitmask and retrieve specific bit
        final byte mask = (byte) (1 << (WIDTH - 1 - x));
        return (buffer[y] & mask) != 0;
    }

    /**
     * Ensures the given X and Y coordinates are within the boundaries of this LED matrix.
     * An {@link IllegalArgumentException} will be thrown if outside.
     *
     * @param x X coordinate to check
     * @param y Y coordinate to check
     */
    private void checkPixelBounds(int x, int y) {
        if (x < 0 || x >= WIDTH) {
            throw new IllegalArgumentException("X must be an integer in the range 0-" + WIDTH);
        }
        if (y < 0 || y >= WIDTH) {
            throw new IllegalArgumentException("Y must be an integer in the range 0-" + HEIGHT);
        }
    }

    /**
     * Helper method for sending a command to the MAX7219 chip with data. Communication happens over SPI by simply sending two pieces of
     * data, more specifically the desired command as a byte value, followed by the data as another byte value.
     *
     * @param command Command to be executed
     * @param data    Data for the given command
     */
    private void execute(byte command, byte data) {
        try {
            spi.write(command, data);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


}
```

程序启动类如下

```java
import com.pi4j.crowpi.app.MAX7219;
import com.pi4j.io.spi.SpiChannel;
import com.pi4j.io.spi.SpiDevice;
import com.pi4j.io.spi.SpiFactory;


/**
 * 〈Application〉
 *
 * @author 丁乾文
 * @date 2022/5/26 01:36
 * @since 1.0.0
 */
public class Application {

    public static int[][] xl = {
            {1, 1, 0, 0, 0, 0, 1, 1},
            {1, 0, 1, 1, 1, 1, 0, 1},
            {0, 1, 0, 1, 1, 0, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 0},
            {0, 1, 0, 1, 1, 0, 1, 0},
            {0, 1, 1, 0, 0, 1, 1, 0},
            {1, 0, 1, 1, 1, 1, 0, 1},
            {1, 1, 0, 0, 0, 0, 1, 1}
    };

    public static void main(String[] args) throws Exception {
        SpiDevice spiDevice = SpiFactory.getInstance(SpiChannel.CS0, SpiDevice.DEFAULT_SPI_SPEED, SpiDevice.DEFAULT_SPI_MODE);
        MAX7219 max7219 = new MAX7219(spiDevice);
        // 先清除屏幕
        max7219.clear().refresh();
        // 开屏
        max7219.setEnabled(true);

        max7219.push(xl);

        // 3秒后自动关闭
        Thread.sleep(3000);
        max7219.setEnabled(false);
    }

}
```

启动后即可看到屏幕上出现一个笑脸😊图案



<Comment></Comment>
