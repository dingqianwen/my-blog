---
lang: zh-CN  
title: é€šè¿‡MAX7219æ¨¡å—é©±åŠ¨çŸ©é˜µå±             
description: é¡µé¢çš„æè¿°
---

# é€šè¿‡MAX7219æ¨¡å—é©±åŠ¨çŸ©é˜µå±

[[toc]]

### æ‰€éœ€ææ–™

- æ ‘è“æ´¾
- MAX7219æ¨¡å—
- 8 * 8 LedçŸ©é˜µ

### æ¨¡å—ä»¥åŠé’ˆè„šä»‹ç»

#### MAX7219

MAX7219æ˜¯MAXIMå…¬å¸ç”Ÿäº§çš„ä¸²è¡Œè¾“å…¥/è¾“å‡ºå…±é˜´ææ•°ç ç®¡æ˜¾ç¤ºé©±åŠ¨èŠ¯ç‰‡ï¼Œä¸€ç‰‡MAX7219å¯é©±åŠ¨8ä¸ª7æ®µï¼ˆåŒ…æ‹¬å°æ•°ç‚¹å…±8æ®µï¼‰æ•°å­—LEDã€LEDæ¡çº¿å›¾å½¢æ˜¾ç¤ºå™¨ã€æˆ–64ä¸ªåˆ†ç«‹çš„LEDå‘å…‰äºŒçº§ç®¡ã€‚è¯¥èŠ¯ç‰‡å…·æœ‰10MHzä¼ è¾“ç‡çš„ä¸‰çº¿ä¸²è¡Œæ¥å£å¯ä¸ä»»ä½•å¾®å¤„ç†å™¨ç›¸è¿ï¼Œåªéœ€ä¸€ä¸ªå¤–æ¥ç”µé˜»å³å¯è®¾ç½®æ‰€æœ‰LEDçš„æ®µç”µæµã€‚

<img src="https://oss-xuxin.oss-cn-beijing.aliyuncs.com/blog/img/lOqudg.png" alt="none" style="width: 35%;height: 35%;border-radius: 6px;">

å„å¼•è„šçš„åŠŸèƒ½ä¸ºï¼š

> DINï¼šä¸²è¡Œæ•°æ®è¾“å…¥ç«¯  
> DOUTï¼šä¸²è¡Œæ•°æ®è¾“å‡ºç«¯ï¼Œç”¨äºçº§è¿æ‰©å±•  
> LOADï¼šè£…è½½æ•°æ®è¾“å…¥  
> CLKï¼šä¸²è¡Œæ—¶é’Ÿè¾“å…¥  
> DIG0~DIG7ï¼š8ä½LEDä½é€‰çº¿ï¼Œä»å…±é˜´æLEDä¸­å¸å…¥ç”µæµ  
> SEG A~SEG G DPï¼š7æ®µé©±åŠ¨å’Œå°æ•°ç‚¹é©±åŠ¨  
> ISETï¼š é€šè¿‡ä¸€ä¸ª10kç”µé˜»å’ŒVccç›¸è¿ï¼Œè®¾ç½®æ®µç”µæµ

### è¿æ¥å›¾

<img src="https://oss-xuxin.oss-cn-beijing.aliyuncs.com/blog/img/MAX7219.drawio.png" alt="none" style="width: 60%;height: 50%;border-radius: 6px;">

### å¯ç”¨SPI

[å¦‚ä½•å¼€å¯SPIï¼Ÿ](å¯ç”¨æ ‘è“æ´¾çš„SPIæ¥å£.md)

### æµ‹è¯•ç¨‹åº

ä¾‹å¦‚æˆ‘ä»¬é€šè¿‡ç¨‹åºè¾“å‡ºä¸€ä¸ªç¬‘è„¸ï¼Œé€šè¿‡äºŒç»´æ•°ç»„æ’åˆ—å›¾å½¢ï¼Œåæ ‡ä¸º0çš„ç‚¹äº®ï¼Œä¸º1çš„ç†„ç­ã€‚

```text
{1, 1, 0, 0, 0, 0, 1, 1},
{1, 0, 1, 1, 1, 1, 0, 1},
{0, 1, 0, 1, 1, 0, 1, 0},
{0, 1, 1, 1, 1, 1, 1, 0},
{0, 1, 0, 1, 1, 0, 1, 0},
{0, 1, 1, 0, 0, 1, 1, 0},
{1, 0, 1, 1, 1, 1, 0, 1},
{1, 1, 0, 0, 0, 0, 1, 1}
```

é‚£æˆ‘ä»¬ç¨‹åºåªè¦çŸ¥é“å¯¹åº”çš„çŸ©é˜µå±åæ ‡ï¼Œå³å¯è½»è€Œæ˜“ä¸¾å®ç°ï¼Œå…¶æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š

```java
public void setPixel(int x, int y, boolean enabled) {
    final byte mask = (byte) (1 << (WIDTH - 1 - x));
    if (enabled) {
        buffer[y] |= mask;
    } else {
        buffer[y] &= ~mask;
    }
}
```

#### å®Œæ•´å®ç°ä»£ç å¦‚ä¸‹ï¼š

é¦–å…ˆå¯¼å…¥æ‰€éœ€ä¾èµ–

```xml

<dependencys>
    <dependency>
        <groupId>com.pi4j</groupId>
        <artifactId>pi4j-core</artifactId>
        <version>1.3</version>
    </dependency>
    <dependency>
        <groupId>com.pi4j</groupId>
        <artifactId>pi4j-gpio-extension</artifactId>
        <version>1.3</version>
    </dependency>
    
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-simple</artifactId>
        <version>1.7.32</version>
    </dependency>
</dependencys>
```

MAX7219å·¥å…·ç±»

```java
import com.pi4j.io.spi.SpiDevice;

import java.io.IOException;
import java.util.Arrays;

/**
 * ã€ˆMAX7219ã€‰
 *
 * @author ä¸ä¹¾æ–‡
 * @date 2022/5/26 19:09
 * @since 1.0.0
 */
public class MAX7219 {

    /**
     * MAX7219: Internal Commands
     */
    private static final byte CMD_SET_FIRST_ROW = 0x01;
    private static final byte CMD_DECODE_MODE = 0x09;
    private static final byte CMD_INTENSITY = 0x0A;
    private static final byte CMD_SCAN_LIMIT = 0x0B;
    private static final byte CMD_SHUTDOWN = 0x0C;
    private static final byte CMD_DISPLAY_TEST = 0x0F;

    /**
     * Width of MAX7219 LED matrix
     */
    public static final int WIDTH = 8;

    /**
     * Height of MAX7219 LED matrix
     */
    public static final int HEIGHT = 8;

    /**
     * Internal buffer to store the 8x8 matrix
     * A byte[] array is used as each of the 8 bits is used to represent a column
     */
    protected final byte[] buffer = new byte[HEIGHT];

    /**
     * Pi4J SPI instance
     */
    protected final SpiDevice spi;

    /**
     * Creates a new MAX7219 instance using the given SPI instance from Pi4J.
     *
     * @param spi SPI instance
     */
    public MAX7219(SpiDevice spi) {
        this.spi = spi;
    }

    /**
     * Clears the internal buffer without refreshing the display.
     * This means that the current contents of the displays are still being shown until {@link #refresh()} is called.
     */
    public MAX7219 clear() {
        Arrays.fill(buffer, (byte) 0);
        return this;
    }

    /**
     * Flushes the internal buffer for all rows to the chip, causing it to be displayed.
     * The contents of the buffer will be preserved by this command.
     */
    public MAX7219 refresh() {
        for (int row = 0; row < HEIGHT; row++) {
            refreshRow(row);
        }
        return this;
    }

    /**
     * Flushes the internal buffer for a single row to the chip, causing it to be displayed.
     * The contents of the buffer will be preserved by this command.
     *
     * @param row Row to be flushed
     */
    protected void refreshRow(int row) {
        if (row < 0 || row >= HEIGHT) {
            throw new IllegalArgumentException("Row must be an integer in the range 0-" + HEIGHT);
        }

        execute((byte) (CMD_SET_FIRST_ROW + row), buffer[row]);
    }

    /**
     * Specifies if the LED matrix should be enabled or disabled.
     * This will also setup the proper decoding mode and scan limit when enabling the chip.
     *
     * @param enabled LED matrix state (true = ON, false = OFF)
     */
    public void setEnabled(boolean enabled) {
        if (enabled) {
            execute(CMD_SHUTDOWN, (byte) 0x01);
            execute(CMD_DECODE_MODE, (byte) 0x00);
            execute(CMD_SCAN_LIMIT, (byte) 0x07);
        } else {
            execute(CMD_SHUTDOWN, (byte) 0x00);
        }
    }

    /**
     * Enables or disables the testing mode of the LED matrix.
     * When enabled, all other options (including {@link #setEnabled(boolean)} are ignored and all LEDs are turned on.
     * To actually control the chip, the test mode MUST be disabled.
     *
     * @param enabled Test mode state (true = ON, false = OFF)
     */
    public void setTestMode(boolean enabled) {
        execute(CMD_DISPLAY_TEST, (byte) (enabled ? 0x01 : 0x00));
    }

    /**
     * Changes the desired brightness for the LED matrix.
     * This method expects an integer value within the range 0-15, with 0 being the dimmest and 15 the brightest possible value.
     * The whole display is affected by this command which gets immediately applied.
     *
     * @param brightness Desired brightness from 0-15
     */
    public void setBrightness(int brightness) {
        if (brightness < 0 || brightness > 15) {
            throw new IllegalArgumentException("Brightness must be an integer in the range 0-15");
        }
        execute(CMD_INTENSITY, (byte) brightness);
    }

    /**
     * Enables or disables the pixel at the given X/Y position within the internal buffer.
     * This change will not be visible until {@link #refresh()} or {@link #refreshRow(int)} gets called.
     *
     * @param x       X position to change
     * @param y       Y position to change
     * @param enabled Desired pixel state (true = ON, false = OFF)
     */
    public void setPixel(int x, int y, boolean enabled) {
        // Ensure coordinates are within boundaries
        checkPixelBounds(x, y);

        // Generate bitmask and set/unset specific bit
        final byte mask = (byte) (1 << (WIDTH - 1 - x));
        if (enabled) {
            buffer[y] |= mask;
        } else {
            buffer[y] &= ~mask;
        }
    }

    /**
     * ä¾‹å¦‚ç¬‘è„¸å›¾æ¡ˆï¼š
     * <pre>
     *     public static int[][] xl = {
     *             {1, 1, 0, 0, 0, 0, 1, 1},
     *             {1, 0, 1, 1, 1, 1, 0, 1},
     *             {0, 1, 0, 1, 1, 0, 1, 0},
     *             {0, 1, 1, 1, 1, 1, 1, 0},
     *             {0, 1, 0, 1, 1, 0, 1, 0},
     *             {0, 1, 1, 0, 0, 1, 1, 0},
     *             {1, 0, 1, 1, 1, 1, 0, 1},
     *             {1, 1, 0, 0, 0, 0, 1, 1}
     *     };
     * </pre>
     *
     * @param ints xy
     */
    public void push(int[][] ints) {
        for (int x = 0; x < ints.length; x++) {
            for (int y = 0; y < ints[x].length; y++) {
                checkPixelBounds(x, y);
                this.setPixel(x, y, ints[x][y] == 0);
            }
        }
        this.refresh();
    }

    /**
     * Retrieves the pixel at the given X/Y position within the internal buffer.
     *
     * @param x X position to change
     * @param y Y position to change
     * @return Current state of specified pixel (true = ON, false = OFF)
     */
    public boolean getPixel(int x, int y) {
        // Ensure coordinates are within boundaries
        checkPixelBounds(x, y);

        // Generate bitmask and retrieve specific bit
        final byte mask = (byte) (1 << (WIDTH - 1 - x));
        return (buffer[y] & mask) != 0;
    }

    /**
     * Ensures the given X and Y coordinates are within the boundaries of this LED matrix.
     * An {@link IllegalArgumentException} will be thrown if outside.
     *
     * @param x X coordinate to check
     * @param y Y coordinate to check
     */
    private void checkPixelBounds(int x, int y) {
        if (x < 0 || x >= WIDTH) {
            throw new IllegalArgumentException("X must be an integer in the range 0-" + WIDTH);
        }
        if (y < 0 || y >= WIDTH) {
            throw new IllegalArgumentException("Y must be an integer in the range 0-" + HEIGHT);
        }
    }

    /**
     * Helper method for sending a command to the MAX7219 chip with data. Communication happens over SPI by simply sending two pieces of
     * data, more specifically the desired command as a byte value, followed by the data as another byte value.
     *
     * @param command Command to be executed
     * @param data    Data for the given command
     */
    private void execute(byte command, byte data) {
        try {
            spi.write(command, data);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


}
```

ç¨‹åºå¯åŠ¨ç±»å¦‚ä¸‹

```java
import com.pi4j.crowpi.app.MAX7219;
import com.pi4j.io.spi.SpiChannel;
import com.pi4j.io.spi.SpiDevice;
import com.pi4j.io.spi.SpiFactory;


/**
 * ã€ˆApplicationã€‰
 *
 * @author ä¸ä¹¾æ–‡
 * @date 2022/5/26 01:36
 * @since 1.0.0
 */
public class Application {

    public static int[][] xl = {
            {1, 1, 0, 0, 0, 0, 1, 1},
            {1, 0, 1, 1, 1, 1, 0, 1},
            {0, 1, 0, 1, 1, 0, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 0},
            {0, 1, 0, 1, 1, 0, 1, 0},
            {0, 1, 1, 0, 0, 1, 1, 0},
            {1, 0, 1, 1, 1, 1, 0, 1},
            {1, 1, 0, 0, 0, 0, 1, 1}
    };

    public static void main(String[] args) throws Exception {
        SpiDevice spiDevice = SpiFactory.getInstance(SpiChannel.CS0, SpiDevice.DEFAULT_SPI_SPEED, SpiDevice.DEFAULT_SPI_MODE);
        MAX7219 max7219 = new MAX7219(spiDevice);
        // å…ˆæ¸…é™¤å±å¹•
        max7219.clear().refresh();
        // å¼€å±
        max7219.setEnabled(true);

        max7219.push(xl);

        // 3ç§’åè‡ªåŠ¨å…³é—­
        Thread.sleep(3000);
        max7219.setEnabled(false);
    }

}
```

å¯åŠ¨åå³å¯çœ‹åˆ°å±å¹•ä¸Šå‡ºç°ä¸€ä¸ªç¬‘è„¸ğŸ˜Šå›¾æ¡ˆ



<Comment></Comment>
